<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D 오목</title>
  <style>
    :root {
      --bg-1: #0b1a2a;
      --bg-2: #1a3550;
      --panel: rgba(10, 18, 28, 0.78);
      --line: rgba(255, 255, 255, 0.15);
      --text: #eaf4ff;
      --muted: #a8bfd6;
      --accent: #63c2ff;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Pretendard", "Noto Sans KR", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1000px 500px at 12% 8%, rgba(120, 170, 240, 0.2), transparent 65%),
        radial-gradient(900px 450px at 85% 90%, rgba(70, 140, 220, 0.22), transparent 70%),
        linear-gradient(140deg, var(--bg-1), var(--bg-2));
      overflow: hidden;
    }

    .hud {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      width: min(980px, calc(100vw - 24px));
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: var(--panel);
      backdrop-filter: blur(8px);
      z-index: 10;
    }

    .hud-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .title {
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .status {
      color: var(--muted);
      font-size: 14px;
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: var(--text);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.06));
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      font-weight: 600;
      transition: 140ms ease;
    }

    button:hover {
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.34);
    }

    button:active {
      transform: translateY(0);
    }

    #app {
      width: 100vw;
      height: 100vh;
    }

    .tip {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--muted);
      font-size: 13px;
      background: rgba(0, 0, 0, 0.28);
      border: 1px solid var(--line);
      padding: 8px 12px;
      border-radius: 10px;
      z-index: 10;
      text-align: center;
    }

    @media (max-width: 760px) {
      .hud {
        flex-direction: column;
        align-items: stretch;
      }

      .actions {
        width: 100%;
      }

      button {
        flex: 1;
      }

      .tip {
        width: calc(100vw - 24px);
      }
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js"
      },
      "scopes": {
        "https://cdn.jsdelivr.net/npm/three@0.161.0/": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js"
        },
        "https://unpkg.com/three@0.161.0/": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js"
        }
      }
    }
  </script>
</head>
<body>
  <div class="hud">
    <div class="hud-left">
      <div class="title">3D 오목</div>
      <div class="status" id="status">흑 차례</div>
    </div>
    <div class="actions">
      <button id="modeBtn" type="button">모드: 사람 vs AI</button>
      <button id="blackDifficultyBtn" type="button">흑 AI: 어려움</button>
      <button id="whiteDifficultyBtn" type="button">백 AI: 어려움</button>
      <button id="undoBtn" type="button">한 수 무르기</button>
      <button id="resetBtn" type="button">새 게임</button>
    </div>
  </div>

  <div id="app" aria-label="3D 오목 보드"></div>
  <div class="tip">드래그: 시점 회전 · 휠: 확대/축소 · 교차점 클릭: 착수</div>

  <script type="module">
    const BOARD_SIZE = 19;
    const HALF_INDEX = (BOARD_SIZE - 1) / 2;
    const app = document.getElementById("app");
    const tipEl = document.querySelector(".tip");
    const statusEl = document.getElementById("status");
    const modeBtn = document.getElementById("modeBtn");
    const blackDifficultyBtn = document.getElementById("blackDifficultyBtn");
    const whiteDifficultyBtn = document.getElementById("whiteDifficultyBtn");
    const undoBtn = document.getElementById("undoBtn");
    const resetBtn = document.getElementById("resetBtn");
    let gameMode = "human_vs_ai";
    let blackAIDifficulty = "hard";
    let whiteAIDifficulty = "hard";

    const DIFFICULTY_ORDER = ["easy", "normal", "hard", "master"];
    const DIFFICULTY_LABEL = {
      easy: "쉬움",
      normal: "보통",
      hard: "어려움",
      master: "최강"
    };
    const GAME_MODE_ORDER = ["human_vs_ai", "ai_vs_ai", "human_vs_human"];
    const GAME_MODE_LABEL = {
      human_vs_ai: "사람 vs AI",
      ai_vs_ai: "AI vs AI",
      human_vs_human: "사람 vs 사람"
    };
    const DIFFICULTY_PRESETS = {
      easy: {
        openingDepth: 1,
        midDepth: 2,
        lateDepth: 2,
        rootCandidates: 8,
        nodeCandidates: 6,
        evalCandidates: 6,
        neighborRadius: 2,
        tacticalWinWeight: 0.5,
        tacticalBlockWeight: 0.36
      },
      normal: {
        openingDepth: 2,
        midDepth: 2,
        lateDepth: 3,
        rootCandidates: 10,
        nodeCandidates: 7,
        evalCandidates: 7,
        neighborRadius: 2,
        tacticalWinWeight: 0.56,
        tacticalBlockWeight: 0.4
      },
      hard: {
        openingDepth: 2,
        midDepth: 3,
        lateDepth: 4,
        rootCandidates: 12,
        nodeCandidates: 8,
        evalCandidates: 8,
        neighborRadius: 2,
        tacticalWinWeight: 0.6,
        tacticalBlockWeight: 0.44
      },
      master: {
        openingDepth: 3,
        midDepth: 4,
        lateDepth: 4,
        rootCandidates: 14,
        nodeCandidates: 9,
        evalCandidates: 9,
        neighborRadius: 2,
        tacticalWinWeight: 0.66,
        tacticalBlockWeight: 0.5
      }
    };

    function updateModeButtonLabel() {
      modeBtn.textContent = `모드: ${GAME_MODE_LABEL[gameMode]}`;
    }

    function updateDifficultyButtonLabel() {
      blackDifficultyBtn.textContent = `흑 AI: ${DIFFICULTY_LABEL[blackAIDifficulty]}`;
      whiteDifficultyBtn.textContent = `백 AI: ${DIFFICULTY_LABEL[whiteAIDifficulty]}`;
    }

    function cycleGameMode() {
      const currentIndex = GAME_MODE_ORDER.indexOf(gameMode);
      gameMode = GAME_MODE_ORDER[(currentIndex + 1) % GAME_MODE_ORDER.length];
      updateModeButtonLabel();
    }

    function cycleDifficulty(player) {
      if (player === 1) {
        const currentIndex = DIFFICULTY_ORDER.indexOf(blackAIDifficulty);
        blackAIDifficulty = DIFFICULTY_ORDER[(currentIndex + 1) % DIFFICULTY_ORDER.length];
      } else {
        const currentIndex = DIFFICULTY_ORDER.indexOf(whiteAIDifficulty);
        whiteAIDifficulty = DIFFICULTY_ORDER[(currentIndex + 1) % DIFFICULTY_ORDER.length];
      }
      updateDifficultyButtonLabel();
    }

    function getDifficultyConfig(difficultyKey) {
      return DIFFICULTY_PRESETS[difficultyKey] ?? DIFFICULTY_PRESETS.hard;
    }

    function getAIDifficultyByPlayer(player) {
      return player === 1 ? blackAIDifficulty : whiteAIDifficulty;
    }

    function isAIControlledPlayer(player) {
      if (gameMode === "ai_vs_ai") return true;
      if (gameMode === "human_vs_ai") return player === 2;
      return false;
    }

    function getUndoCountByMode() {
      if (gameMode === "human_vs_human") return 1;
      return 2;
    }

    function createCoreState() {
      return {
        boardState: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0)),
        moveStack: [],
        currentPlayer: 1,
        winner: 0,
        lastMove: null
      };
    }

    const AI_CONFIG = { winScore: 900000000 };

    function getSearchSettings(stoneCount, cfg) {
      if (stoneCount < 8) {
        return {
          depth: cfg.openingDepth,
          rootCandidates: cfg.rootCandidates,
          nodeCandidates: cfg.nodeCandidates,
          neighborRadius: cfg.neighborRadius
        };
      }
      if (stoneCount < 28) {
        return {
          depth: cfg.midDepth,
          rootCandidates: cfg.rootCandidates,
          nodeCandidates: cfg.nodeCandidates,
          neighborRadius: cfg.neighborRadius
        };
      }
      return {
        depth: cfg.lateDepth,
        rootCandidates: Math.max(8, cfg.rootCandidates - 2),
        nodeCandidates: Math.max(6, cfg.nodeCandidates - 1),
        neighborRadius: cfg.neighborRadius
      };
    }

    function findWinLine(boardState, x, y, player) {
      const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
      for (const [dx, dy] of directions) {
        const cells = [[x, y]];
        for (const dir of [1, -1]) {
          let step = 1;
          while (true) {
            const nx = x + dx * step * dir;
            const ny = y + dy * step * dir;
            if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
            if (boardState[ny][nx] !== player) break;
            cells.push([nx, ny]);
            step += 1;
          }
        }
        if (cells.length >= 5) return cells;
      }
      return null;
    }

    function isDoubleThreeForbidden(boardState, x, y, player) {
      // This build enforces only 3x3 foul for black(1).
      if (player !== 1) return false;
      if (boardState[y][x] !== 0) return true;

      boardState[y][x] = player;
      let openThreeCount = 0;
      const dirs = [[1, 0], [0, 1], [1, 1], [1, -1]];

      function readCell(px, py) {
        if (px < 0 || py < 0 || px >= BOARD_SIZE || py >= BOARD_SIZE) return "2";
        const v = boardState[py][px];
        if (v === 0) return "0";
        if (v === 1) return "1";
        return "2";
      }

      function countOpenThreeFromDirection(dx, dy) {
        // 9-cell line around new stone, center index = 4
        const line = [];
        for (let i = -4; i <= 4; i++) {
          line.push(readCell(x + dx * i, y + dy * i));
        }
        const s = line.join("");

        // Canonical open-three patterns (straight/broken).
        const patterns = ["01110", "011010", "010110"];
        let count = 0;

        for (const p of patterns) {
          const len = p.length;
          for (let i = 0; i <= s.length - len; i++) {
            const w = s.slice(i, i + len);
            if (w !== p) continue;
            const centerInWindow = i <= 4 && 4 < i + len;
            if (!centerInWindow) continue;

            // Exclude extended runs (e.g., hidden 4+) from being treated as open-three.
            const leftOutside = i - 1 >= 0 ? s[i - 1] : "2";
            const rightOutside = i + len < s.length ? s[i + len] : "2";
            if (leftOutside === "1" || rightOutside === "1") continue;
            count += 1;
          }
        }
        return count;
      }

      for (const [dx, dy] of dirs) {
        openThreeCount += countOpenThreeFromDirection(dx, dy);
      }

      boardState[y][x] = 0;
      return openThreeCount >= 2;
    }

    function setStatus(mode, text) {
      statusEl.textContent = `[${mode}] ${text}`;
    }

    function forEachEmpty(boardState, cb) {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (boardState[y][x] === 0) cb(x, y);
        }
      }
    }

    function isLegalMove(boardState, x, y, player) {
      return boardState[y][x] === 0 && !isDoubleThreeForbidden(boardState, x, y, player);
    }

    function wouldWinByMove(boardState, x, y, player) {
      if (!isLegalMove(boardState, x, y, player)) return false;
      boardState[y][x] = player;
      const win = !!findWinLine(boardState, x, y, player);
      boardState[y][x] = 0;
      return win;
    }

    function evaluateCell(boardState, x, y, player) {
      const dirs = [[1, 0], [0, 1], [1, 1], [1, -1]];
      let score = 0;

      function walk(dx, dy) {
        let cnt = 0;
        let nx = x + dx;
        let ny = y + dy;
        while (nx >= 0 && ny >= 0 && nx < BOARD_SIZE && ny < BOARD_SIZE && boardState[ny][nx] === player) {
          cnt += 1;
          nx += dx;
          ny += dy;
        }
        const open = nx >= 0 && ny >= 0 && nx < BOARD_SIZE && ny < BOARD_SIZE && boardState[ny][nx] === 0;
        return { cnt, open };
      }

      for (const [dx, dy] of dirs) {
        const a = walk(dx, dy);
        const b = walk(-dx, -dy);
        const len = a.cnt + b.cnt + 1;
        const openEnds = (a.open ? 1 : 0) + (b.open ? 1 : 0);
        if (len >= 5) return 1_000_000_000;
        if (len === 4) score += openEnds === 2 ? 240_000 : 60_000;
        else if (len === 3) score += openEnds === 2 ? 30_000 : 7_500;
        else if (len === 2) score += openEnds === 2 ? 3_000 : 700;
        else score += openEnds === 2 ? 120 : 25;
      }

      const cx = HALF_INDEX;
      const cy = HALF_INDEX;
      const centerBias = 22 - (Math.abs(x - cx) + Math.abs(y - cy));
      return score + Math.max(0, centerBias * 20);
    }

    function hasNeighborStone(boardState, x, y, radius = 2) {
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= BOARD_SIZE || ny >= BOARD_SIZE) continue;
          if (boardState[ny][nx] !== 0) return true;
        }
      }
      return false;
    }

    function generateCandidateMoves(boardState, player, opponent, cfg, limit = 12, radius = null) {
      const neighborRadius = radius ?? cfg.neighborRadius;
      const candidates = [];
      let hasStone = false;
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (boardState[y][x] !== 0) {
            hasStone = true;
            continue;
          }
          if (!isLegalMove(boardState, x, y, player)) continue;
          if (!hasNeighborStone(boardState, x, y, neighborRadius) && hasStone) continue;
          const attack = evaluateCell(boardState, x, y, player);
          const defend = evaluateCell(boardState, x, y, opponent);
          let tactical = 0;
          if (wouldWinByMove(boardState, x, y, player)) {
            tactical += AI_CONFIG.winScore * cfg.tacticalWinWeight;
          } else if (wouldWinByMove(boardState, x, y, opponent)) {
            tactical += AI_CONFIG.winScore * cfg.tacticalBlockWeight;
          }
          const score = tactical + attack * 1.16 + defend * 1.05;
          candidates.push({ x, y, score });
        }
      }

      if (candidates.length === 0 && isLegalMove(boardState, HALF_INDEX, HALF_INDEX, player)) {
        return [{ x: HALF_INDEX, y: HALF_INDEX, score: 0 }];
      }

      candidates.sort((a, b) => b.score - a.score);
      return candidates.slice(0, limit);
    }

    function evaluateBoardState(boardState, aiPlayer, humanPlayer) {
      const cfg = getDifficultyConfig(getAIDifficultyByPlayer(aiPlayer));
      const aiCand = generateCandidateMoves(boardState, aiPlayer, humanPlayer, cfg, cfg.evalCandidates, cfg.neighborRadius);
      const humanCfg = getDifficultyConfig(getAIDifficultyByPlayer(humanPlayer));
      const humanCand = generateCandidateMoves(boardState, humanPlayer, aiPlayer, humanCfg, humanCfg.evalCandidates, humanCfg.neighborRadius);
      const aiScore = (aiCand[0]?.score ?? 0) * 1.2 + (aiCand[1]?.score ?? 0) * 0.62 + (aiCand[2]?.score ?? 0) * 0.35;
      const humanScore = (humanCand[0]?.score ?? 0) * 1.26 + (humanCand[1]?.score ?? 0) * 0.68 + (humanCand[2]?.score ?? 0) * 0.4;
      return aiScore - humanScore;
    }

    function minimax(boardState, depth, currentPlayer, aiPlayer, humanPlayer, alpha, beta, maxDepth, nodeCandidates, neighborRadius, cfg) {
      if (depth === 0) {
        return evaluateBoardState(boardState, aiPlayer, humanPlayer);
      }

      const opponent = currentPlayer === 1 ? 2 : 1;
      const moves = generateCandidateMoves(
        boardState,
        currentPlayer,
        opponent,
        cfg,
        nodeCandidates,
        neighborRadius
      );
      if (moves.length === 0) {
        return evaluateBoardState(boardState, aiPlayer, humanPlayer);
      }

      if (currentPlayer === aiPlayer) {
        let best = -Infinity;
        for (const move of moves) {
          boardState[move.y][move.x] = currentPlayer;
          let score;
          if (findWinLine(boardState, move.x, move.y, currentPlayer)) {
            score = AI_CONFIG.winScore - (maxDepth - depth);
          } else {
            score = minimax(boardState, depth - 1, opponent, aiPlayer, humanPlayer, alpha, beta, maxDepth, nodeCandidates, neighborRadius, cfg);
          }
          boardState[move.y][move.x] = 0;
          if (score > best) best = score;
          if (best > alpha) alpha = best;
          if (beta <= alpha) break;
        }
        return best;
      }

      let best = Infinity;
      for (const move of moves) {
        boardState[move.y][move.x] = currentPlayer;
        let score;
        if (findWinLine(boardState, move.x, move.y, currentPlayer)) {
          score = -AI_CONFIG.winScore + (maxDepth - depth);
        } else {
          score = minimax(boardState, depth - 1, opponent, aiPlayer, humanPlayer, alpha, beta, maxDepth, nodeCandidates, neighborRadius, cfg);
        }
        boardState[move.y][move.x] = 0;
        if (score < best) best = score;
        if (best < beta) beta = best;
        if (beta <= alpha) break;
      }
      return best;
    }

    function chooseAIMove(boardState, aiPlayer = 2, humanPlayer = 1, difficultyKey = "hard") {
      const cfg = getDifficultyConfig(difficultyKey);
      const empties = [];
      forEachEmpty(boardState, (x, y) => {
        if (isLegalMove(boardState, x, y, aiPlayer)) empties.push({ x, y });
      });
      if (empties.length === 0) return null;
      const stoneCount = BOARD_SIZE * BOARD_SIZE - empties.length;
      const settings = getSearchSettings(stoneCount, cfg);

      if (empties.length === BOARD_SIZE * BOARD_SIZE) {
        return { x: HALF_INDEX, y: HALF_INDEX };
      }

      for (const c of empties) {
        if (wouldWinByMove(boardState, c.x, c.y, aiPlayer)) return c;
      }
      for (const c of empties) {
        if (wouldWinByMove(boardState, c.x, c.y, humanPlayer)) return c;
      }

      const aiCandidates = generateCandidateMoves(
        boardState,
        aiPlayer,
        humanPlayer,
        cfg,
        settings.rootCandidates,
        settings.neighborRadius
      );
      if (aiCandidates.length === 0) return empties[0];

      let best = aiCandidates[0];
      let bestScore = -Infinity;
      for (const c of aiCandidates) {
        boardState[c.y][c.x] = aiPlayer;
        let moveScore = -Infinity;
        if (findWinLine(boardState, c.x, c.y, aiPlayer)) {
          moveScore = AI_CONFIG.winScore;
        } else {
          const opponent = aiPlayer === 1 ? 2 : 1;
          moveScore = minimax(
            boardState,
            settings.depth - 1,
            opponent,
            aiPlayer,
            humanPlayer,
            -Infinity,
            Infinity,
            settings.depth,
            settings.nodeCandidates,
            settings.neighborRadius,
            cfg
          );
        }

        boardState[c.y][c.x] = 0;

        const tieBreak = Math.random() * 2;
        if (moveScore + tieBreak > bestScore) {
          bestScore = moveScore;
          best = c;
        }
      }

      return { x: best.x, y: best.y };
    }

    async function loadThreeModules() {
      const sources = [
        {
          three: "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
          controls: "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js"
        },
        {
          three: "https://unpkg.com/three@0.161.0/build/three.module.js",
          controls: "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js"
        }
      ];
      let lastError;
      for (const src of sources) {
        try {
          const THREE = await import(src.three);
          const controlsMod = await import(src.controls);
          const OrbitControls = controlsMod.OrbitControls ?? controlsMod.default;
          if (!OrbitControls) throw new Error("OrbitControls export missing");
          return { THREE, OrbitControls };
        } catch (err) {
          lastError = err;
        }
      }
      throw lastError;
    }

    function init2DFallback() {
      app.innerHTML = "";
      tipEl.textContent = "현재 환경에서 3D를 불러오지 못해 2D 모드로 실행 중입니다.";
      const canvas = document.createElement("canvas");
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      canvas.style.display = "block";
      app.appendChild(canvas);

      const ctx = canvas.getContext("2d");
      const state = createCoreState();
      const marginRatio = 0.1;
      let aiTimer = null;

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = Math.floor(window.innerWidth * dpr);
        canvas.height = Math.floor(window.innerHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        draw();
      }

      function layout() {
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.86;
        const boardSize = Math.max(320, Math.min(760, size));
        const left = (window.innerWidth - boardSize) / 2;
        const top = (window.innerHeight - boardSize) / 2 + 28;
        const pad = boardSize * marginRatio;
        const cell = (boardSize - pad * 2) / (BOARD_SIZE - 1);
        return { boardSize, left, top, pad, cell };
      }

      function draw() {
        const { boardSize, left, top, pad, cell } = layout();
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

        const grad = ctx.createLinearGradient(left, top, left + boardSize, top + boardSize);
        grad.addColorStop(0, "#f0c88f");
        grad.addColorStop(1, "#d6a56a");
        ctx.fillStyle = grad;
        ctx.fillRect(left, top, boardSize, boardSize);

        ctx.strokeStyle = "rgba(75, 40, 15, 0.85)";
        ctx.lineWidth = 1;
        for (let i = 0; i < BOARD_SIZE; i++) {
          const p = pad + i * cell;
          ctx.beginPath();
          ctx.moveTo(left + pad, top + p);
          ctx.lineTo(left + boardSize - pad, top + p);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(left + p, top + pad);
          ctx.lineTo(left + p, top + boardSize - pad);
          ctx.stroke();
        }

        const stars = [[3, 3], [3, 9], [3, 15], [9, 3], [9, 9], [9, 15], [15, 3], [15, 9], [15, 15]];
        ctx.fillStyle = "#422711";
        for (const [x, y] of stars) {
          const cx = left + pad + x * cell;
          const cy = top + pad + y * cell;
          ctx.beginPath();
          ctx.arc(cx, cy, Math.max(2.2, cell * 0.07), 0, Math.PI * 2);
          ctx.fill();
        }

        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            const value = state.boardState[y][x];
            if (!value) continue;
            const cx = left + pad + x * cell;
            const cy = top + pad + y * cell;
            const r = Math.max(7, cell * 0.42);
            const sg = ctx.createRadialGradient(cx - r * 0.25, cy - r * 0.35, r * 0.2, cx, cy, r);
            if (value === 1) {
              sg.addColorStop(0, "#5e5e5e");
              sg.addColorStop(1, "#111");
            } else {
              sg.addColorStop(0, "#fff");
              sg.addColorStop(1, "#d7d7d7");
            }
            ctx.fillStyle = sg;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        if (state.lastMove) {
          const cx = left + pad + state.lastMove.x * cell;
          const cy = top + pad + state.lastMove.y * cell;
          const rr = Math.max(9, cell * 0.5);
          ctx.strokeStyle = "#ff4a4a";
          ctx.lineWidth = Math.max(2, cell * 0.09);
          ctx.beginPath();
          ctx.arc(cx, cy, rr, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      function updateTurnText() {
        if (state.winner === 1) setStatus("2D", "흑 승리");
        else if (state.winner === 2) setStatus("2D", "백 승리");
        else if (state.winner === -1) setStatus("2D", "무승부");
        else if (isAIControlledPlayer(state.currentPlayer)) {
          const side = state.currentPlayer === 1 ? "흑" : "백";
          const level = DIFFICULTY_LABEL[getAIDifficultyByPlayer(state.currentPlayer)];
          setStatus("2D", `${side} AI(${level}) 생각 중...`);
        }
        else setStatus("2D", `${state.currentPlayer === 1 ? "흑" : "백"} 차례`);
      }

      function maybeRunAI() {
        if (state.winner !== 0 || !isAIControlledPlayer(state.currentPlayer)) return;
        if (aiTimer) clearTimeout(aiTimer);
        updateTurnText();
        const aiPlayer = state.currentPlayer;
        const humanPlayer = aiPlayer === 1 ? 2 : 1;
        const difficultyKey = getAIDifficultyByPlayer(aiPlayer);
        aiTimer = setTimeout(() => {
          const move = chooseAIMove(state.boardState, aiPlayer, humanPlayer, difficultyKey);
          if (!move || state.winner !== 0 || state.currentPlayer !== aiPlayer || !isAIControlledPlayer(state.currentPlayer)) return;
          applyMove(move.x, move.y);
        }, 220);
      }

      function applyMove(x, y) {
        if (isDoubleThreeForbidden(state.boardState, x, y, state.currentPlayer)) {
          setStatus("2D", "흑 금수(3x3): 다른 곳에 두세요");
          return;
        }
        state.boardState[y][x] = state.currentPlayer;
        state.moveStack.push({ x, y, p: state.currentPlayer });
        state.lastMove = { x, y };
        const line = findWinLine(state.boardState, x, y, state.currentPlayer);
        if (line) state.winner = state.currentPlayer;
        else if (state.moveStack.length === BOARD_SIZE * BOARD_SIZE) state.winner = -1;
        else state.currentPlayer = state.currentPlayer === 1 ? 2 : 1;
        updateTurnText();
        draw();
        maybeRunAI();
      }

      function clickToCell(evt) {
        const { boardSize, left, top, pad, cell } = layout();
        const r = canvas.getBoundingClientRect();
        const x = evt.clientX - r.left;
        const y = evt.clientY - r.top;
        if (x < left || y < top || x > left + boardSize || y > top + boardSize) return null;
        const ix = Math.round((x - left - pad) / cell);
        const iy = Math.round((y - top - pad) / cell);
        if (ix < 0 || iy < 0 || ix >= BOARD_SIZE || iy >= BOARD_SIZE) return null;
        return { x: ix, y: iy };
      }

      canvas.addEventListener("click", (evt) => {
        if (isAIControlledPlayer(state.currentPlayer)) return;
        if (state.winner !== 0) return;
        const cell = clickToCell(evt);
        if (!cell || state.boardState[cell.y][cell.x] !== 0) return;
        applyMove(cell.x, cell.y);
      });

      resetBtn.onclick = () => {
        if (aiTimer) clearTimeout(aiTimer);
        const s = createCoreState();
        state.boardState = s.boardState;
        state.moveStack = s.moveStack;
        state.currentPlayer = s.currentPlayer;
        state.winner = s.winner;
        state.lastMove = s.lastMove;
        updateTurnText();
        draw();
      };

      undoBtn.onclick = () => {
        if (aiTimer) clearTimeout(aiTimer);
        const undoCount = getUndoCountByMode();
        let last = null;
        for (let i = 0; i < undoCount; i++) {
          last = state.moveStack.pop();
          if (!last) break;
          state.boardState[last.y][last.x] = 0;
        }
        if (!last) return;
        state.currentPlayer = gameMode === "human_vs_human" ? last.p : 1;
        state.winner = 0;
        const prev = state.moveStack[state.moveStack.length - 1];
        state.lastMove = prev ? { x: prev.x, y: prev.y } : null;
        updateTurnText();
        draw();
      };

      modeBtn.onclick = () => {
        if (aiTimer) clearTimeout(aiTimer);
        cycleGameMode();
        updateTurnText();
        maybeRunAI();
      };
      blackDifficultyBtn.onclick = () => {
        cycleDifficulty(1);
        updateTurnText();
        maybeRunAI();
      };
      whiteDifficultyBtn.onclick = () => {
        cycleDifficulty(2);
        updateTurnText();
        maybeRunAI();
      };

      window.addEventListener("resize", resize);
      updateModeButtonLabel();
      updateDifficultyButtonLabel();
      updateTurnText();
      resize();
      maybeRunAI();
    }

    function init3D(THREE, OrbitControls) {
      const CELL = 1;
      const BOARD_THICKNESS = 0.62;
      const BOARD_Y = BOARD_THICKNESS / 2;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      app.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0c1c2d, 14, 36);

      const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 120);
      camera.position.set(0, 14, 14);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 0.2, 0);
      controls.maxPolarAngle = Math.PI * 0.48;
      controls.minDistance = 11;
      controls.maxDistance = 28;

      scene.add(new THREE.AmbientLight(0xffffff, 0.55));
      const keyLight = new THREE.DirectionalLight(0xfff2dc, 1.05);
      keyLight.position.set(9, 18, 11);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(2048, 2048);
      keyLight.shadow.camera.left = -18;
      keyLight.shadow.camera.right = 18;
      keyLight.shadow.camera.top = 18;
      keyLight.shadow.camera.bottom = -18;
      scene.add(keyLight);
      const fillLight = new THREE.DirectionalLight(0x9cc8ff, 0.35);
      fillLight.position.set(-10, 8, -8);
      scene.add(fillLight);

      const textureLoader = new THREE.TextureLoader();
      const woodColor = textureLoader.load("https://threejs.org/examples/textures/hardwood2_diffuse.jpg");
      const woodBump = textureLoader.load("https://threejs.org/examples/textures/hardwood2_bump.jpg");
      [woodColor, woodBump].forEach((tx) => {
        tx.wrapS = THREE.RepeatWrapping;
        tx.wrapT = THREE.RepeatWrapping;
        tx.repeat.set(2.4, 2.4);
        tx.anisotropy = renderer.capabilities.getMaxAnisotropy();
      });

      const boardExtent = HALF_INDEX * CELL + 0.8;
      const board = new THREE.Mesh(
        new THREE.BoxGeometry(boardExtent * 2, BOARD_THICKNESS, boardExtent * 2),
        new THREE.MeshStandardMaterial({
          map: woodColor,
          bumpMap: woodBump,
          bumpScale: 0.12,
          roughness: 0.72,
          metalness: 0.02,
          color: 0xe8c996
        })
      );
      board.position.y = BOARD_Y;
      board.receiveShadow = true;
      board.castShadow = true;
      scene.add(board);

      const floor = new THREE.Mesh(
        new THREE.CircleGeometry(24, 96),
        new THREE.MeshStandardMaterial({ color: 0x0d2237, roughness: 0.95, metalness: 0 })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -0.001;
      floor.receiveShadow = true;
      scene.add(floor);

      const gridGroup = new THREE.Group();
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4f2d0f, transparent: true, opacity: 0.86 });
      for (let i = 0; i < BOARD_SIZE; i++) {
        const offset = (i - HALF_INDEX) * CELL;
        const h = [new THREE.Vector3(-HALF_INDEX * CELL, BOARD_THICKNESS + 0.001, offset), new THREE.Vector3(HALF_INDEX * CELL, BOARD_THICKNESS + 0.001, offset)];
        const v = [new THREE.Vector3(offset, BOARD_THICKNESS + 0.001, -HALF_INDEX * CELL), new THREE.Vector3(offset, BOARD_THICKNESS + 0.001, HALF_INDEX * CELL)];
        gridGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(h), lineMaterial));
        gridGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(v), lineMaterial));
      }

      const starMaterial = new THREE.MeshBasicMaterial({ color: 0x3a220d });
      for (const [x, y] of [[3, 3], [3, 9], [3, 15], [9, 3], [9, 9], [9, 15], [15, 3], [15, 9], [15, 15]]) {
        const marker = new THREE.Mesh(new THREE.SphereGeometry(0.08, 14, 14), starMaterial);
        marker.position.set((x - HALF_INDEX) * CELL, BOARD_THICKNESS + 0.02, (y - HALF_INDEX) * CELL);
        gridGroup.add(marker);
      }
      scene.add(gridGroup);

      const state = createCoreState();
      const placedStones = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(null));
      const stoneGroup = new THREE.Group();
      scene.add(stoneGroup);

      const stoneGeometry = new THREE.CylinderGeometry(0.41, 0.43, 0.26, 48);
      const blackMaterial = new THREE.MeshStandardMaterial({ color: 0x1b1b1b, roughness: 0.35, metalness: 0.12 });
      const whiteMaterial = new THREE.MeshStandardMaterial({ color: 0xf6f6f6, roughness: 0.24, metalness: 0.08 });
      const ghostStone = new THREE.Mesh(
        stoneGeometry,
        new THREE.MeshStandardMaterial({ color: 0x6ec4ff, transparent: true, opacity: 0.45, roughness: 0.25, metalness: 0.1 })
      );
      ghostStone.position.y = BOARD_THICKNESS + 0.135;
      ghostStone.visible = false;
      scene.add(ghostStone);

      const lastMoveRing = new THREE.Mesh(
        new THREE.TorusGeometry(0.52, 0.06, 14, 48),
        new THREE.MeshStandardMaterial({
          color: 0xff4a4a,
          emissive: 0x4a0000,
          emissiveIntensity: 0.55,
          roughness: 0.3,
          metalness: 0.18
        })
      );
      lastMoveRing.rotation.x = -Math.PI / 2;
      lastMoveRing.position.y = BOARD_THICKNESS + 0.28;
      lastMoveRing.visible = false;
      scene.add(lastMoveRing);

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      const boardPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -BOARD_THICKNESS);
      const idxToWorld = (i) => (i - HALF_INDEX) * CELL;
      const worldToIdx = (v) => Math.round(v / CELL + HALF_INDEX);
      let aiTimer = null;

      function syncLastMoveMarker() {
        if (!state.lastMove) {
          lastMoveRing.visible = false;
          return;
        }
        lastMoveRing.visible = true;
        lastMoveRing.position.x = idxToWorld(state.lastMove.x);
        lastMoveRing.position.z = idxToWorld(state.lastMove.y);
      }

      function getCellFromPointer(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        const hitPoint = new THREE.Vector3();
        if (!raycaster.ray.intersectPlane(boardPlane, hitPoint)) return null;
        const x = worldToIdx(hitPoint.x);
        const y = worldToIdx(hitPoint.z);
        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return null;
        return { x, y };
      }

      function updateTurnText() {
        if (state.winner === 1) setStatus("3D", "흑 승리");
        else if (state.winner === 2) setStatus("3D", "백 승리");
        else if (state.winner === -1) setStatus("3D", "무승부");
        else if (isAIControlledPlayer(state.currentPlayer)) {
          const side = state.currentPlayer === 1 ? "흑" : "백";
          const level = DIFFICULTY_LABEL[getAIDifficultyByPlayer(state.currentPlayer)];
          setStatus("3D", `${side} AI(${level}) 생각 중...`);
        }
        else setStatus("3D", `${state.currentPlayer === 1 ? "흑" : "백"} 차례`);
      }

      function maybeRunAI() {
        if (state.winner !== 0 || !isAIControlledPlayer(state.currentPlayer)) return;
        if (aiTimer) clearTimeout(aiTimer);
        updateTurnText();
        const aiPlayer = state.currentPlayer;
        const humanPlayer = aiPlayer === 1 ? 2 : 1;
        const difficultyKey = getAIDifficultyByPlayer(aiPlayer);
        aiTimer = setTimeout(() => {
          const move = chooseAIMove(state.boardState, aiPlayer, humanPlayer, difficultyKey);
          if (!move || state.winner !== 0 || state.currentPlayer !== aiPlayer || !isAIControlledPlayer(state.currentPlayer)) return;
          placeStone(move.x, move.y);
        }, 220);
      }

      function placeStone(x, y) {
        if (isDoubleThreeForbidden(state.boardState, x, y, state.currentPlayer)) {
          setStatus("3D", "흑 금수(3x3): 다른 곳에 두세요");
          return;
        }
        state.boardState[y][x] = state.currentPlayer;
        const stone = new THREE.Mesh(stoneGeometry, state.currentPlayer === 1 ? blackMaterial : whiteMaterial);
        stone.castShadow = true;
        stone.receiveShadow = true;
        stone.position.set(idxToWorld(x), BOARD_THICKNESS + 0.135, idxToWorld(y));
        stoneGroup.add(stone);
        placedStones[y][x] = stone;
        state.moveStack.push({ x, y, player: state.currentPlayer });
        state.lastMove = { x, y };
        syncLastMoveMarker();

        const winLine = findWinLine(state.boardState, x, y, state.currentPlayer);
        if (winLine) {
          state.winner = state.currentPlayer;
          for (const [wx, wy] of winLine.slice(0, 5)) {
            const ws = placedStones[wy][wx];
            ws.material = ws.material.clone();
            ws.material.emissive = new THREE.Color(0x3ca8ff);
            ws.material.emissiveIntensity = 0.4;
          }
        } else if (state.moveStack.length === BOARD_SIZE * BOARD_SIZE) {
          state.winner = -1;
        } else {
          state.currentPlayer = state.currentPlayer === 1 ? 2 : 1;
        }
        updateTurnText();
        maybeRunAI();
      }

      function resetGame() {
        if (aiTimer) clearTimeout(aiTimer);
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            state.boardState[y][x] = 0;
            if (placedStones[y][x]) {
              stoneGroup.remove(placedStones[y][x]);
              placedStones[y][x] = null;
            }
          }
        }
        state.moveStack.length = 0;
        state.currentPlayer = 1;
        state.winner = 0;
        state.lastMove = null;
        ghostStone.visible = false;
        syncLastMoveMarker();
        updateTurnText();
        maybeRunAI();
      }

      function undoMove() {
        if (aiTimer) clearTimeout(aiTimer);
        const undoCount = getUndoCountByMode();
        let last = null;
        for (let i = 0; i < undoCount; i++) {
          last = state.moveStack.pop();
          if (!last) break;
          state.boardState[last.y][last.x] = 0;
          stoneGroup.remove(placedStones[last.y][last.x]);
          placedStones[last.y][last.x] = null;
        }
        if (!last) return;
        state.currentPlayer = gameMode === "human_vs_human" ? last.player : 1;
        state.winner = 0;
        const prev = state.moveStack[state.moveStack.length - 1];
        state.lastMove = prev ? { x: prev.x, y: prev.y } : null;
        syncLastMoveMarker();
        updateTurnText();
      }

      renderer.domElement.addEventListener("pointermove", (event) => {
        if (state.winner !== 0) {
          ghostStone.visible = false;
          return;
        }
        if (isAIControlledPlayer(state.currentPlayer)) {
          ghostStone.visible = false;
          return;
        }
        const cell = getCellFromPointer(event);
        if (!cell || state.boardState[cell.y][cell.x] !== 0) {
          ghostStone.visible = false;
          return;
        }
        ghostStone.visible = true;
        ghostStone.position.x = idxToWorld(cell.x);
        ghostStone.position.z = idxToWorld(cell.y);
        ghostStone.material.color.set(state.currentPlayer === 1 ? 0x272727 : 0xfefefe);
      });
      renderer.domElement.addEventListener("pointerleave", () => { ghostStone.visible = false; });
      renderer.domElement.addEventListener("click", (event) => {
        if (isAIControlledPlayer(state.currentPlayer)) return;
        if (state.winner !== 0) return;
        const cell = getCellFromPointer(event);
        if (!cell || state.boardState[cell.y][cell.x] !== 0) return;
        placeStone(cell.x, cell.y);
      });

      resetBtn.onclick = resetGame;
      undoBtn.onclick = undoMove;
      modeBtn.onclick = () => {
        if (aiTimer) clearTimeout(aiTimer);
        cycleGameMode();
        updateTurnText();
        maybeRunAI();
      };
      blackDifficultyBtn.onclick = () => {
        cycleDifficulty(1);
        updateTurnText();
        maybeRunAI();
      };
      whiteDifficultyBtn.onclick = () => {
        cycleDifficulty(2);
        updateTurnText();
        maybeRunAI();
      };
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      updateModeButtonLabel();
      updateDifficultyButtonLabel();
      updateTurnText();
      maybeRunAI();
      (function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      })();
    }

    try {
      const { THREE, OrbitControls } = await loadThreeModules();
      tipEl.textContent = "드래그: 시점 회전 · 휠: 확대/축소 · 교차점 클릭: 착수";
      init3D(THREE, OrbitControls);
    } catch (err) {
      console.error("3D 로드 실패, 2D 폴백 실행:", err);
      init2DFallback();
    }
  </script>
</body>
</html>
